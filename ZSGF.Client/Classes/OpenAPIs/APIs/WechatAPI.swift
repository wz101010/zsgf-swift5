//
// WechatAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class WechatAPI {

    /**
     确认二维码登录请求
     
     - parameter appKey: (path)  
     - parameter qRCodeSignInRequest: (body) 登录确认请求参数 (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func confirmQRCodeLogin(appKey: String, qRCodeSignInRequest: QRCodeSignInRequest? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: TokenModelApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return confirmQRCodeLoginWithRequestBuilder(appKey: appKey, qRCodeSignInRequest: qRCodeSignInRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     确认二维码登录请求
     - POST /Wechat/{appKey}/QR-Auth/Confirm-Login
     - 微信小程序用户确认二维码登录并获取访问令牌
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter qRCodeSignInRequest: (body) 登录确认请求参数 (optional)
     - returns: RequestBuilder<TokenModelApiResponse> 
     */
    open class func confirmQRCodeLoginWithRequestBuilder(appKey: String, qRCodeSignInRequest: QRCodeSignInRequest? = nil) -> RequestBuilder<TokenModelApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/QR-Auth/Confirm-Login"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: qRCodeSignInRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<TokenModelApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     确认二维码注册请求
     
     - parameter appKey: (path)  
     - parameter qRCodeSignUpRequest: (body) 注册确认请求参数 (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func confirmQRCodeRegistration(appKey: String, qRCodeSignUpRequest: QRCodeSignUpRequest? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: TokenModelApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return confirmQRCodeRegistrationWithRequestBuilder(appKey: appKey, qRCodeSignUpRequest: qRCodeSignUpRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     确认二维码注册请求
     - POST /Wechat/{appKey}/QR-Auth/Confirm-Register
     - 微信小程序用户通过二维码完成注册并获取访问令牌
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter qRCodeSignUpRequest: (body) 注册确认请求参数 (optional)
     - returns: RequestBuilder<TokenModelApiResponse> 
     */
    open class func confirmQRCodeRegistrationWithRequestBuilder(appKey: String, qRCodeSignUpRequest: QRCodeSignUpRequest? = nil) -> RequestBuilder<TokenModelApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/QR-Auth/Confirm-Register"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: qRCodeSignUpRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<TokenModelApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     初始化二维码认证会话
     
     - parameter appKey: (path)  
     - parameter qRCodePreSignInRequest: (body) 认证会话初始化请求参数 (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func initiateQRAuthSession(appKey: String, qRCodePreSignInRequest: QRCodePreSignInRequest? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: Int64ApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return initiateQRAuthSessionWithRequestBuilder(appKey: appKey, qRCodePreSignInRequest: qRCodePreSignInRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     初始化二维码认证会话
     - POST /Wechat/{appKey}/QR-Auth/Initiate
     - 创建用于微信小程序扫码登录/注册的认证会话
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter qRCodePreSignInRequest: (body) 认证会话初始化请求参数 (optional)
     - returns: RequestBuilder<Int64ApiResponse> 
     */
    open class func initiateQRAuthSessionWithRequestBuilder(appKey: String, qRCodePreSignInRequest: QRCodePreSignInRequest? = nil) -> RequestBuilder<Int64ApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/QR-Auth/Initiate"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: qRCodePreSignInRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Int64ApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     验证二维码扫描结果
     
     - parameter appKey: (path)  
     - parameter qRCodeScanRequest: (body) 二维码扫描请求参数 (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func scanQRCodeForAuth(appKey: String, qRCodeScanRequest: QRCodeScanRequest? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: UserQRCodeScanResultApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return scanQRCodeForAuthWithRequestBuilder(appKey: appKey, qRCodeScanRequest: qRCodeScanRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     验证二维码扫描结果
     - POST /Wechat/{appKey}/QR-Auth/Scan
     - 微信小程序扫描二维码并获取应用授权信息
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter qRCodeScanRequest: (body) 二维码扫描请求参数 (optional)
     - returns: RequestBuilder<UserQRCodeScanResultApiResponse> 
     */
    open class func scanQRCodeForAuthWithRequestBuilder(appKey: String, qRCodeScanRequest: QRCodeScanRequest? = nil) -> RequestBuilder<UserQRCodeScanResultApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/QR-Auth/Scan"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: qRCodeScanRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<UserQRCodeScanResultApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     解密小程序用户数据
     
     - parameter appKey: (path)  
     - parameter encryptedData: (query) 加密的数据 (optional)
     - parameter iv: (query) 加密算法的初始向量 (optional)
     - parameter sessionKey: (query) 会话密钥 (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatDecrypt(appKey: String, encryptedData: String? = nil, iv: String? = nil, sessionKey: String? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: StringApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatDecryptWithRequestBuilder(appKey: appKey, encryptedData: encryptedData, iv: iv, sessionKey: sessionKey).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     解密小程序用户数据
     - GET /Wechat/{appKey}/Decrypt
     - 解密小程序加密数据
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter encryptedData: (query) 加密的数据 (optional)
     - parameter iv: (query) 加密算法的初始向量 (optional)
     - parameter sessionKey: (query) 会话密钥 (optional)
     - returns: RequestBuilder<StringApiResponse> 
     */
    open class func wechatDecryptWithRequestBuilder(appKey: String, encryptedData: String? = nil, iv: String? = nil, sessionKey: String? = nil) -> RequestBuilder<StringApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/Decrypt"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "encryptedData": (wrappedValue: encryptedData?.encodeToJSON(), isExplode: true),
            "iv": (wrappedValue: iv?.encodeToJSON(), isExplode: true),
            "sessionKey": (wrappedValue: sessionKey?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<StringApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     生成小程序Scheme码
     
     - parameter appKey: (path)  
     - parameter requestBody: (body) scheme码数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/qrcode-link/url-scheme/generateScheme.html (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatGenerateScheme(appKey: String, requestBody: [AnyCodable]? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: StringApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatGenerateSchemeWithRequestBuilder(appKey: appKey, requestBody: requestBody).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     生成小程序Scheme码
     - POST /Wechat/{appKey}/GenerateScheme
     - 生成小程序的scheme码
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter requestBody: (body) scheme码数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/qrcode-link/url-scheme/generateScheme.html (optional)
     - returns: RequestBuilder<StringApiResponse> 
     */
    open class func wechatGenerateSchemeWithRequestBuilder(appKey: String, requestBody: [AnyCodable]? = nil) -> RequestBuilder<StringApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/GenerateScheme"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: requestBody)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<StringApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     校验小程序登录状态
     
     - parameter appKey: (path)  
     - parameter jsCode: (query) 登录凭证，开发参考：https://dwz.cn/icNajFh7 (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatJSCode2Session(appKey: String, jsCode: String? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: StringApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatJSCode2SessionWithRequestBuilder(appKey: appKey, jsCode: jsCode).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     校验小程序登录状态
     - GET /Wechat/{appKey}/JSCode2Session
     - 校验小程序登录凭证
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter jsCode: (query) 登录凭证，开发参考：https://dwz.cn/icNajFh7 (optional)
     - returns: RequestBuilder<StringApiResponse> 
     */
    open class func wechatJSCode2SessionWithRequestBuilder(appKey: String, jsCode: String? = nil) -> RequestBuilder<StringApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/JSCode2Session"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "js_code": (wrappedValue: jsCode?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<StringApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     配置公众号JS SDK
     
     - parameter appKey: (path)  
     - parameter url: (query) 当前网页的URL (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatJSConfig(appKey: String, url: String? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: WechatJSConfigResultApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatJSConfigWithRequestBuilder(appKey: appKey, url: url).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     配置公众号JS SDK
     - GET /Wechat/{appKey}/JSConfig
     - 获取公众号H5的JS SDK配置
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter url: (query) 当前网页的URL (optional)
     - returns: RequestBuilder<WechatJSConfigResultApiResponse> 
     */
    open class func wechatJSConfigWithRequestBuilder(appKey: String, url: String? = nil) -> RequestBuilder<WechatJSConfigResultApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/JSConfig"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "url": (wrappedValue: url?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WechatJSConfigResultApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     小程序内容安全检测
     
     - parameter appKey: (path)  
     - parameter requestBody: (body) 消息内容数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/sec-center/sec-check/msgSecCheck.html (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatMsgSecCheck(appKey: String, requestBody: [AnyCodable]? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: AnyCodable?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatMsgSecCheckWithRequestBuilder(appKey: appKey, requestBody: requestBody).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     小程序内容安全检测
     - POST /Wechat/{appKey}/MsgSecCheck
     - 检测消息内容是否含有违法违规信息
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter requestBody: (body) 消息内容数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/sec-center/sec-check/msgSecCheck.html (optional)
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func wechatMsgSecCheckWithRequestBuilder(appKey: String, requestBody: [AnyCodable]? = nil) -> RequestBuilder<AnyCodable> {
        var localVariablePath = "/Wechat/{appKey}/MsgSecCheck"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: requestBody)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     发送公众号一次性订阅消息
     
     - parameter appKey: (path)  
     - parameter requestBody: (body) 订阅消息数据，开发参考：https://dwz.cn/IXptek5n (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatSubscribeMSG(appKey: String, requestBody: [AnyCodable]? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: StringApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatSubscribeMSGWithRequestBuilder(appKey: appKey, requestBody: requestBody).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     发送公众号一次性订阅消息
     - POST /Wechat/{appKey}/SubscribeMSG
     - 发送公众号H5一次性订阅消息
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter requestBody: (body) 订阅消息数据，开发参考：https://dwz.cn/IXptek5n (optional)
     - returns: RequestBuilder<StringApiResponse> 
     */
    open class func wechatSubscribeMSGWithRequestBuilder(appKey: String, requestBody: [AnyCodable]? = nil) -> RequestBuilder<StringApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/SubscribeMSG"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: requestBody)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<StringApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     发送小程序订阅消息
     
     - parameter appKey: (path)  
     - parameter requestBody: (body) 订阅消息数据，开发参考：https://dwz.cn/bohXaCnp (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatSubscribeSend(appKey: String, requestBody: [AnyCodable]? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: StringApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatSubscribeSendWithRequestBuilder(appKey: appKey, requestBody: requestBody).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     发送小程序订阅消息
     - POST /Wechat/{appKey}/SubscribeSend
     - 发送小程序订阅消息
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter requestBody: (body) 订阅消息数据，开发参考：https://dwz.cn/bohXaCnp (optional)
     - returns: RequestBuilder<StringApiResponse> 
     */
    open class func wechatSubscribeSendWithRequestBuilder(appKey: String, requestBody: [AnyCodable]? = nil) -> RequestBuilder<StringApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/SubscribeSend"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: requestBody)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<StringApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     生成小程序URL跳转链接
     
     - parameter appKey: (path)  
     - parameter requestBody: (body) 跳转地址数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/url-link/urllink.generate.html (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatUrlLinkGenerate(appKey: String, requestBody: [AnyCodable]? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: StringApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatUrlLinkGenerateWithRequestBuilder(appKey: appKey, requestBody: requestBody).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     生成小程序URL跳转链接
     - POST /Wechat/{appKey}/UrlLinkGenerate
     - 生成小程序的网页跳转地址
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter requestBody: (body) 跳转地址数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/url-link/urllink.generate.html (optional)
     - returns: RequestBuilder<StringApiResponse> 
     */
    open class func wechatUrlLinkGenerateWithRequestBuilder(appKey: String, requestBody: [AnyCodable]? = nil) -> RequestBuilder<StringApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/UrlLinkGenerate"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: requestBody)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<StringApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     获取公众号H5 UnionID
     
     - parameter appKey: (path)  
     - parameter openid: (query) 用户的OpenID (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatUserInfo(appKey: String, openid: String? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: StringApiResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatUserInfoWithRequestBuilder(appKey: appKey, openid: openid).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     获取公众号H5 UnionID
     - GET /Wechat/{appKey}/UserInfo
     - 获取公众号H5用户的UnionID
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter openid: (query) 用户的OpenID (optional)
     - returns: RequestBuilder<StringApiResponse> 
     */
    open class func wechatUserInfoWithRequestBuilder(appKey: String, openid: String? = nil) -> RequestBuilder<StringApiResponse> {
        var localVariablePath = "/Wechat/{appKey}/UserInfo"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "openid": (wrappedValue: openid?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<StringApiResponse>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     获取小程序码（普通）
     
     - parameter appKey: (path)  
     - parameter requestBody: (body) 小程序码数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatWXACodeGet(appKey: String, requestBody: [AnyCodable]? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: URL?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatWXACodeGetWithRequestBuilder(appKey: appKey, requestBody: requestBody).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     获取小程序码（普通）
     - POST /Wechat/{appKey}/WXACodeGet
     - 获取小程序码
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter requestBody: (body) 小程序码数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html (optional)
     - returns: RequestBuilder<URL> 
     */
    open class func wechatWXACodeGetWithRequestBuilder(appKey: String, requestBody: [AnyCodable]? = nil) -> RequestBuilder<URL> {
        var localVariablePath = "/Wechat/{appKey}/WXACodeGet"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: requestBody)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<URL>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     获取小程序码（无限制）
     
     - parameter appKey: (path)  
     - parameter requestBody: (body) 小程序码数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func wechatWXACodeGetUnlimited(appKey: String, requestBody: [AnyCodable]? = nil, apiResponseQueue: DispatchQueue = ZSGF.ClientAPI.apiResponseQueue, completion: @escaping ((_ data: URL?, _ error: Error?) -> Void)) -> RequestTask {
        return wechatWXACodeGetUnlimitedWithRequestBuilder(appKey: appKey, requestBody: requestBody).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     获取小程序码（无限制）
     - POST /Wechat/{appKey}/WXACodeGetUnlimited
     - 获取无限制的小程序码
     - Bearer Token:
       - type: http
       - name: Bearer
     - parameter appKey: (path)  
     - parameter requestBody: (body) 小程序码数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html (optional)
     - returns: RequestBuilder<URL> 
     */
    open class func wechatWXACodeGetUnlimitedWithRequestBuilder(appKey: String, requestBody: [AnyCodable]? = nil) -> RequestBuilder<URL> {
        var localVariablePath = "/Wechat/{appKey}/WXACodeGetUnlimited"
        let appKeyPreEscape = "\(APIHelper.mapValueToPathItem(appKey))"
        let appKeyPostEscape = appKeyPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{appKey}", with: appKeyPostEscape, options: .literal, range: nil)
        let localVariableURLString = ZSGF.ClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: requestBody)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json-patch+json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<URL>.Type = ZSGF.ClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }
}
